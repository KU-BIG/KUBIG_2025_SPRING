pipeline {
    agent any  // Jenkins Podì—ì„œ ì‹¤í–‰
    
    environment {
        // ì±—ë´‡ í”„ë¡œì íŠ¸ ì •ë³´
        APP_NAME = 'kubig25ss-etf-chatbot'
        DOCKER_TAG = "${BUILD_NUMBER}"
        K8S_NAMESPACE = 'etf-chatbot'
        K8S_DEPLOYMENT = 'etf-chatbot'
        K8S_CONTAINER = 'etf-chatbot'
    }

    parameters {
        choice(
            name: 'DEPLOY_TYPE',
            choices: ['build-and-deploy', 'build-only', 'deploy-only'],
            description: 'ë°°í¬ ìœ í˜•ì„ ì„ íƒí•˜ì„¸ìš”'
        )
        string(
            name: 'GIT_BRANCH',
            defaultValue: 'junseok',
            description: 'ë¹Œë“œí•  Git ë¸Œëœì¹˜ëª…'
        )
    }

    stages {
        stage('etup & Validation') {
            steps {
                script {
                    echo "ETF ì±—ë´‡ CI/CD íŒŒì´í”„ë¼ì¸ ì‹œì‘ (Kaniko ë¹Œë“œ)"
                    echo "ë¹Œë“œ ë²ˆí˜¸: ${BUILD_NUMBER}"
                    echo "ë°°í¬ ìœ í˜•: ${params.DEPLOY_TYPE}"
                    
                    // í™˜ê²½ í™•ì¸
                    sh '''
                        echo "=== í™˜ê²½ í™•ì¸ ==="
                        kubectl version --client || echo "kubectl ì„¤ì¹˜ í•„ìš”"
                        ls -la chatbot-app/
                    '''
                }
            }
        }

        stage('Prepare Secrets') {
            when {
                expression { params.DEPLOY_TYPE in ['build-and-deploy', 'build-only'] }
            }
            steps {
                withCredentials([
                    usernamePassword(
                        credentialsId: 'docker-hub-credentials',
                        usernameVariable: 'DOCKER_USERNAME',
                        passwordVariable: 'DOCKER_PASSWORD'
                    ),
                    usernamePassword(
                        credentialsId: 'github-credentials',
                        usernameVariable: 'GITHUB_USERNAME',
                        passwordVariable: 'GITHUB_PASSWORD'
                    )
                ]) {
                    script {
                        env.DOCKER_IMAGE = "${DOCKER_USERNAME}/${APP_NAME}"
                        env.GIT_BRANCH = "${params.GIT_BRANCH}".replaceAll("^origin/", "")
                        
                        echo "í™˜ê²½ë³€ìˆ˜ ì„¤ì • ì™„ë£Œ:"
                        echo "  - Docker Image: ${env.DOCKER_IMAGE}"
                        echo "  - Git Branch: ${env.GIT_BRANCH} (origin/ ì œê±°ë¨)"
                        echo "  - Build Number: ${BUILD_NUMBER}"
                        
                        // Secret ìƒì„±
                        sh '''
                            echo "=== Docker Secret ìƒì„± ==="
                            
                            # ë„¤ì„ìŠ¤í˜ì´ìŠ¤ ìƒì„± (ì—†ìœ¼ë©´ ìë™ ìƒì„±)
                            echo "ë„¤ì„ìŠ¤í˜ì´ìŠ¤ ${K8S_NAMESPACE} í™•ì¸ ì¤‘..."
                            kubectl create namespace ${K8S_NAMESPACE} --dry-run=client -o yaml | kubectl apply -f -
                            echo "ë„¤ì„ìŠ¤í˜ì´ìŠ¤ ${K8S_NAMESPACE} ì¤€ë¹„ ì™„ë£Œ"
                            
                            # Docker config.json ìƒì„±
                            mkdir -p /tmp/docker-config
                            cat > /tmp/docker-config/config.json << EOF
{
    "auths": {
        "https://index.docker.io/v1/": {
            "auth": "$(echo -n "${DOCKER_USERNAME}:${DOCKER_PASSWORD}" | base64 -w 0)"
        }
    }
}
EOF
                            
                            # Kubernetes Secret ìƒì„± (Dockerë§Œ)
                            kubectl create secret generic docker-config \
                                --from-file=/tmp/docker-config/config.json \
                                --namespace=${K8S_NAMESPACE} \
                                --dry-run=client -o yaml | kubectl apply -f -
                            
                            # Secret ë™ê¸°í™” ëŒ€ê¸°
                            echo "Secret ë™ê¸°í™” ëŒ€ê¸° (10ì´ˆ)"
                            sleep 10
                            
                            # Secret ì¡´ì¬ í™•ì¸
                            kubectl get secret docker-config -n ${K8S_NAMESPACE}
                            echo "Docker Secret ì¤€ë¹„ ì™„ë£Œ"
                        '''
                    }
                }
            }
        }

        stage('ğŸ—ï¸ Build with Kaniko') {
            when {
                expression { params.DEPLOY_TYPE in ['build-and-deploy', 'build-only'] }
            }
            steps {
                withCredentials([
                    usernamePassword(
                        credentialsId: 'docker-hub-credentials',
                        usernameVariable: 'DOCKER_USERNAME',
                        passwordVariable: 'DOCKER_PASSWORD'
                    ),
                    usernamePassword(
                        credentialsId: 'github-credentials',
                        usernameVariable: 'GITHUB_USERNAME',
                        passwordVariable: 'GITHUB_PASSWORD'
                    )
                ]) {
                    script {
                        // í™˜ê²½ë³€ìˆ˜ ì„¤ì •
                        env.DOCKER_IMAGE = "${DOCKER_USERNAME}/${APP_NAME}"
                        env.GIT_BRANCH_CLEAN = "${params.GIT_BRANCH}".replaceAll("^origin/", "")
                        
                        echo "ì´ë¯¸ì§€: ${env.DOCKER_IMAGE}:${DOCKER_TAG}"
                        echo "ë¸Œëœì¹˜: ${env.GIT_BRANCH_CLEAN} (ì •ë¦¬ë¨)"
                        
                        // Git credentials í™•ì¸
                        echo "Git ì‚¬ìš©ì: ${GITHUB_USERNAME}"
                        echo "Docker ì‚¬ìš©ì: ${DOCKER_USERNAME}"
                    }
                    
                    // Kanikoë¡œ ì´ë¯¸ì§€ ë¹Œë“œ
                    sh '''
                            echo "=== Git ì†ŒìŠ¤ ì¤€ë¹„ ==="
                            
                            # Jenkinsì—ì„œ Git clone (credentials ì‚¬ìš©)
                            rm -rf /tmp/source
                            echo "Git clone ì‹œì‘: ë¸Œëœì¹˜ ${GIT_BRANCH_CLEAN}"
                            git clone -b ${GIT_BRANCH_CLEAN} https://${GITHUB_USERNAME}:${GITHUB_PASSWORD}@github.com/junseok0913/25SS-Conference-Project.git /tmp/source
                            
                            # ì†ŒìŠ¤ í™•ì¸
                            ls -la /tmp/source/chatbot-app/
                            
                            echo "=== Kanikoë¡œ Docker ì´ë¯¸ì§€ ë¹Œë“œ ==="
                            
                            # ì†ŒìŠ¤ ì½”ë“œë¥¼ ConfigMapìœ¼ë¡œ ìƒì„± (ì••ì¶•)
                            cd /tmp/source/chatbot-app
                            tar czf /tmp/source.tar.gz .
                            kubectl create configmap source-context \
                                --from-file=source.tar.gz=/tmp/source.tar.gz \
                                --namespace=${K8S_NAMESPACE} \
                                --dry-run=client -o yaml | kubectl apply -f -
                            
                            # Kaniko Job ìƒì„±
                            cat > kaniko-build.yaml << EOF
apiVersion: batch/v1
kind: Job
metadata:
  name: kaniko-build-${BUILD_NUMBER}
  namespace: ${K8S_NAMESPACE}
spec:
  template:
    spec:
      restartPolicy: Never
      affinity:
        nodeAffinity:
          requiredDuringSchedulingIgnoredDuringExecution:
            nodeSelectorTerms:
            - matchExpressions:
              - key: node-role.kubernetes.io/control-plane
                operator: DoesNotExist
      tolerations: []
      containers:
      - name: kaniko
        image: gcr.io/kaniko-project/executor:latest
        args: 
        - "--dockerfile=Dockerfile"
        - "--context=tar:///workspace/source.tar.gz"
        - "--destination=${DOCKER_IMAGE}:${DOCKER_TAG}"
        - "--cache=false"
        - "--verbosity=warn"
        - "--single-snapshot"
        - "--cleanup"
        - "--compressed-caching=false"
        - "--use-new-run"
        - "--push-retry=3"
        resources:
          requests:
            memory: "1Gi"
            cpu: "500m"
          limits:
            memory: "4Gi"
            cpu: "500m"
        volumeMounts:
        - name: docker-config
          mountPath: /kaniko/.docker/
        - name: source-context
          mountPath: /workspace
        env:
        - name: GOOGLE_APPLICATION_CREDENTIALS
          value: /kaniko/.docker/config.json
      volumes:
      - name: docker-config
        secret:
          secretName: docker-config
          defaultMode: 0600
          items:
          - key: config.json
            path: config.json
      - name: source-context
        configMap:
          name: source-context
EOF
                            
                            # Job ì‹¤í–‰
                            kubectl apply -f kaniko-build.yaml
                            
                            # Job ì™„ë£Œ ëŒ€ê¸° (30ë¶„)
                            kubectl wait --for=condition=complete job/kaniko-build-${BUILD_NUMBER} \
                                --namespace=${K8S_NAMESPACE} \
                                --timeout=1800s
                            
                            # ë¹Œë“œ ë¡œê·¸ í™•ì¸
                            kubectl logs job/kaniko-build-${BUILD_NUMBER} --namespace=${K8S_NAMESPACE}
                            
                            echo "=== ë¹Œë“œ ì™„ë£Œ ==="
                            echo "ì´ë¯¸ì§€: ${DOCKER_IMAGE}:${DOCKER_TAG}"
                        '''
                }
            }
        }

        stage('Deploy to Kubernetes') {
            when {
                expression { params.DEPLOY_TYPE in ['build-and-deploy', 'deploy-only'] }
            }
            steps {
                withCredentials([
                    usernamePassword(
                        credentialsId: 'docker-hub-credentials',
                        usernameVariable: 'DOCKER_USERNAME',
                        passwordVariable: 'DOCKER_PASSWORD'
                    ),
                    usernamePassword(
                        credentialsId: 'aws-credentials',
                        usernameVariable: 'AWS_ACCESS_KEY_ID',
                        passwordVariable: 'AWS_SECRET_ACCESS_KEY'
                    ),
                    string(credentialsId: 'openai-api-key', variable: 'OPENAI_API_KEY'),
                    string(credentialsId: 'aws-s3-bucket', variable: 'AWS_S3_BUCKET'),
                    string(credentialsId: 'aws-region', variable: 'AWS_REGION'),
                    string(credentialsId: 'langchain-api-key', variable: 'LANGCHAIN_API_KEY')
                ]) {
                    script {
                        env.DOCKER_IMAGE = "${DOCKER_USERNAME}/${APP_NAME}"
                    }
                    sh '''
                        echo "=== ì¿ ë²„ë„¤í‹°ìŠ¤ ë°°í¬ ì‹œì‘ ==="
                        
                        # ë„¤ì„ìŠ¤í˜ì´ìŠ¤ ìƒì„±
                        kubectl create namespace ${K8S_NAMESPACE} --dry-run=client -o yaml | kubectl apply -f -
                        
                        # Secrets ì—…ë°ì´íŠ¸
                        kubectl create secret generic etf-chatbot-secrets \
                            --from-literal=OPENAI_API_KEY="${OPENAI_API_KEY}" \
                            --from-literal=AWS_ACCESS_KEY_ID="${AWS_ACCESS_KEY_ID}" \
                            --from-literal=AWS_SECRET_ACCESS_KEY="${AWS_SECRET_ACCESS_KEY}" \
                            --from-literal=AWS_S3_BUCKET="${AWS_S3_BUCKET}" \
                            --from-literal=AWS_REGION="${AWS_REGION}" \
                            --from-literal=LANGCHAIN_API_KEY="${LANGCHAIN_API_KEY}" \
                            --from-literal=LANGCHAIN_PROJECT="25ss-kubig" \
                            --namespace=${K8S_NAMESPACE} \
                            --dry-run=client -o yaml | kubectl apply -f -
                        
                        # ë¦¬ì†ŒìŠ¤ ì ìš© (ServiceAccount ë¨¼ì €)
                        kubectl apply -f chatbot-app/k8s/serviceaccount.yaml
                        kubectl apply -f chatbot-app/k8s/configmap.yaml
                        
                        # StorageClass ì¡°ê±´ë¶€ ìƒì„± (í´ëŸ¬ìŠ¤í„° ë ˆë²¨)
                        kubectl apply -f chatbot-app/k8s/storageclass-multiattach.yaml
                        
                        # PVC ì¡°ê±´ë¶€ ìƒì„±
                        if ! kubectl get pvc etf-chatbot-data-multi -n ${K8S_NAMESPACE} >/dev/null 2>&1; then
                            echo "PVCê°€ ì¡´ì¬í•˜ì§€ ì•ŠìŒ - ìƒˆë¡œ ìƒì„±í•©ë‹ˆë‹¤"
                            kubectl apply -f chatbot-app/k8s/pvc-multiattach.yaml
                        else
                            echo "PVCê°€ ì´ë¯¸ ì¡´ì¬í•¨ - ê¸°ì¡´ PVC ì‚¬ìš©"
                            kubectl get pvc etf-chatbot-data-multi -n ${K8S_NAMESPACE}
                        fi
                        
                        # ì´ë¯¸ì§€ íƒœê·¸ ì„¤ì • (deploy-onlyë©´ latest, ì•„ë‹ˆë©´ ë¹Œë“œë²ˆí˜¸)
                        if [ "${DEPLOY_TYPE}" = "deploy-only" ]; then
                            sed -i "s|BUILD_TAG|29|g" chatbot-app/k8s/chatbot-deployment.yaml
                        else
                            sed -i "s|BUILD_TAG|${DOCKER_TAG}|g" chatbot-app/k8s/chatbot-deployment.yaml
                        fi
                        
                        # ë°°í¬ ì ìš© (NodePort í™˜ê²½ - Ingress ì œì™¸)
                        kubectl apply -f chatbot-app/k8s/chatbot-deployment.yaml
                        kubectl apply -f chatbot-app/k8s/chatbot-service.yaml
                        
                        # latest íƒœê·¸ì¼ ë•Œ ê°•ì œ ì¬ë°°í¬ (ìƒˆ ì´ë¯¸ì§€ pull)
                        if [ "${DEPLOY_TYPE}" = "deploy-only" ]; then
                            echo "=== latest ì´ë¯¸ì§€ ê°•ì œ ì¬ë°°í¬ ==="
                            kubectl rollout restart deployment/${K8S_DEPLOYMENT} --namespace=${K8S_NAMESPACE}
                        fi
                        
                        # ë°°í¬ ìƒíƒœ í™•ì¸
                        kubectl rollout status deployment/${K8S_DEPLOYMENT} \
                            --namespace=${K8S_NAMESPACE} \
                            --timeout=600s
                    '''
                }
            }
        }

        stage('Health Check') {
            when {
                expression { params.DEPLOY_TYPE in ['build-and-deploy', 'deploy-only'] }
            }
            steps {
                sh '''
                    echo "=== ì• í”Œë¦¬ì¼€ì´ì…˜ í—¬ìŠ¤ ì²´í¬ ==="
                    
                    # Pod ìƒíƒœ í™•ì¸
                    kubectl get pods -n ${K8S_NAMESPACE} -l app=etf-chatbot
                    
                    # ì„œë¹„ìŠ¤ í™•ì¸
                    kubectl get services -n ${K8S_NAMESPACE}
                    
                    # NodePortë¡œ ì§ì ‘ í—¬ìŠ¤ ì²´í¬
                    echo "NodePort ì„œë¹„ìŠ¤ í™•ì¸:"
                    kubectl get svc etf-chatbot-nodeport -n ${K8S_NAMESPACE}
                    
                    # ë…¸ë“œ IP í™•ì¸
                    NODE_IP=$(kubectl get nodes -o jsonpath='{.items[0].status.addresses[?(@.type=="ExternalIP")].address}')
                    if [ -z "$NODE_IP" ]; then
                        NODE_IP=$(kubectl get nodes -o jsonpath='{.items[0].status.addresses[?(@.type=="InternalIP")].address}')
                        echo "External IP ì—†ìŒ, Internal IP ì‚¬ìš©: $NODE_IP"
                    else
                        echo "External IP ì‚¬ìš©: $NODE_IP"
                    fi
                    
                    echo "ì ‘ì† ì •ë³´:"
                    echo "FastAPI: http://$NODE_IP:30800/ping"
                    echo "Streamlit: http://$NODE_IP:30801/"
                    
                    # Internal í—¬ìŠ¤ ì²´í¬ (í´ëŸ¬ìŠ¤í„° ë‚´ë¶€ì—ì„œ)
                    kubectl run temp-curl --image=curlimages/curl --rm -i --restart=Never -- \
                        curl -f http://etf-chatbot-service.${K8S_NAMESPACE}.svc.cluster.local:8000/ping \
                        && echo "ë‚´ë¶€ í—¬ìŠ¤ ì²´í¬ ì„±ê³µ" || echo "ë‚´ë¶€ í—¬ìŠ¤ ì²´í¬ ì‹¤íŒ¨"
                '''
            }
        }
    }

    post {
        always {
            script {
                // Kaniko Job ì •ë¦¬
                sh '''
                    kubectl delete job kaniko-build-${BUILD_NUMBER} \
                        --namespace=${K8S_NAMESPACE} \
                        --ignore-not-found=true
                '''
                
                def buildStatus = currentBuild.result ?: 'SUCCESS'
                echo """
                â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                ETF ì±—ë´‡ ë¹Œë“œ ì™„ë£Œ (Kaniko)
                â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                ìƒíƒœ: ${buildStatus}
                ë²„ì „: ${BUILD_NUMBER}
                ì´ë¯¸ì§€: ${env.DOCKER_IMAGE ?: 'N/A'}:${DOCKER_TAG}
                â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                """
            }
        }
        
        cleanup {
            sh '''
                # ì„ì‹œ íŒŒì¼ ì •ë¦¬
                rm -f kaniko-build.yaml
                rm -rf /tmp/docker-config
                rm -rf /tmp/source
                rm -f /tmp/source.tar.gz
                
                # ConfigMap ì •ë¦¬
                kubectl delete configmap source-context \
                    --namespace=${K8S_NAMESPACE} \
                    --ignore-not-found=true
            '''
        }
    }
} 